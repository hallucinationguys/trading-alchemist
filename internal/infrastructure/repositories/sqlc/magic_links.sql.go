// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: magic_links.sql

package sqlc

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredMagicLinks = `-- name: CleanupExpiredMagicLinks :exec
DELETE FROM magic_links 
WHERE expires_at < NOW() - INTERVAL '1 day'
`

func (q *Queries) CleanupExpiredMagicLinks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredMagicLinks)
	return err
}

const createMagicLink = `-- name: CreateMagicLink :one
INSERT INTO magic_links (user_id, token, token_hash, expires_at, ip_address, user_agent, purpose)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, token, token_hash, expires_at, used_at, ip_address, user_agent, purpose, created_at
`

type CreateMagicLinkParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	Token     string             `json:"token"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	IpAddress *netip.Addr        `json:"ip_address"`
	UserAgent pgtype.Text        `json:"user_agent"`
	Purpose   string             `json:"purpose"`
}

func (q *Queries) CreateMagicLink(ctx context.Context, arg CreateMagicLinkParams) (MagicLink, error) {
	row := q.db.QueryRow(ctx, createMagicLink,
		arg.UserID,
		arg.Token,
		arg.TokenHash,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
		arg.Purpose,
	)
	var i MagicLink
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.Purpose,
		&i.CreatedAt,
	)
	return i, err
}

const getMagicLinkByToken = `-- name: GetMagicLinkByToken :one
SELECT ml.id, ml.user_id, ml.token, ml.token_hash, ml.expires_at, ml.used_at, ml.ip_address, ml.user_agent, ml.purpose, ml.created_at, u.email, u.email_verified 
FROM magic_links ml
JOIN users u ON ml.user_id = u.id
WHERE ml.token = $1 
  AND ml.expires_at > NOW()
  AND ml.used_at IS NULL
  AND u.is_active = true
`

type GetMagicLinkByTokenRow struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	Token         string             `json:"token"`
	TokenHash     string             `json:"token_hash"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
	UsedAt        pgtype.Timestamptz `json:"used_at"`
	IpAddress     *netip.Addr        `json:"ip_address"`
	UserAgent     pgtype.Text        `json:"user_agent"`
	Purpose       string             `json:"purpose"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Email         string             `json:"email"`
	EmailVerified pgtype.Bool        `json:"email_verified"`
}

func (q *Queries) GetMagicLinkByToken(ctx context.Context, token string) (GetMagicLinkByTokenRow, error) {
	row := q.db.QueryRow(ctx, getMagicLinkByToken, token)
	var i GetMagicLinkByTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.Purpose,
		&i.CreatedAt,
		&i.Email,
		&i.EmailVerified,
	)
	return i, err
}

const invalidateUserMagicLinks = `-- name: InvalidateUserMagicLinks :exec
UPDATE magic_links 
SET used_at = NOW()
WHERE user_id = $1 
  AND purpose = $2 
  AND used_at IS NULL
`

type InvalidateUserMagicLinksParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Purpose string      `json:"purpose"`
}

func (q *Queries) InvalidateUserMagicLinks(ctx context.Context, arg InvalidateUserMagicLinksParams) error {
	_, err := q.db.Exec(ctx, invalidateUserMagicLinks, arg.UserID, arg.Purpose)
	return err
}

const useMagicLink = `-- name: UseMagicLink :one
UPDATE magic_links 
SET used_at = NOW()
WHERE id = $1
RETURNING id, user_id, token, token_hash, expires_at, used_at, ip_address, user_agent, purpose, created_at
`

func (q *Queries) UseMagicLink(ctx context.Context, id pgtype.UUID) (MagicLink, error) {
	row := q.db.QueryRow(ctx, useMagicLink, id)
	var i MagicLink
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.Purpose,
		&i.CreatedAt,
	)
	return i, err
}
